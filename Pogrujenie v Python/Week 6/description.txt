На предыдущей неделе вы разработали клиентское сетевое приложение — клиента для сервера метрик, который умеет
отправлять и получать данные о различных численных показателях. Пришло время финального задания — в нем необходимо
реализовать серверную часть.

Как обычно, вам необходимо разработать программу в одном файле-модуле, который вы загрузите на проверку обычным
способом. Сервер должен соответствовать протоколу, который был описан в задании к предыдущей неделе. Он должен уметь
принимать от клиентов команды put и get, разбирать их, и формировать ответ согласно протоколу. По запросу put требуется
сохранять метрики в структурах данных в памяти процесса. По запросу get сервер обязан отдавать данные в правильной
последовательности. При работе с клиентом сервер должен поддерживать сессии, соединение с клиентом между запросами
не должно "разрываться".

На верхнем уровне вашего модуля должна быть объявлена функция run_server(host, port) — она принимает адрес и порт,
на которых должен быть запущен сервер.

Для проверки правильности решения мы воспользуемся своей реализацией клиента и будем отправлять на ваш сервер put и
get запросы, ожидая в ответ правильные данные от сервера (согласно объявленному протоколу). Все запросы будут
выполняться с таймаутом — сервер должен отвечать за приемлемое время.

Сервер должен быть готов к неправильным командам со стороны клиента и отдавать клиенту ошибку в формате, оговоренном в
протоколе. В этих случаях работа сервера не должна завершаться аварийно.

На последней неделе мы с вами разбирали пример tcp-сервера на asyncio: (server.py)

Данный код создает tcp-соединение для адреса 127.0.0.1:8181 и слушает все входящие запросы. При подключении клиента
будет создан новый экземпляр класса ClientServerProtocol, а при поступлении новых данных вызовется метод этого
объекта - data_received. Внутри asyncio.Protocol спрятана вся магия обработки запросов через корутины, остается
реализовать протокол взаимодействия между клиентом и сервером.

Вы можете использовать этот код, как основу при написании вашей реализации сервера. Это не обязательное требование.
Для реализации задачи вы можете использовать любые вызовы из стандартной библиотеки Python 3 (обратим ваше внимание,
что в грейдере установлена версия Python 3.6).  Сервер должен уметь обрабатывать запросы от нескольких клиентов
одновременно.

В процессе разработки сервера для тестирования работоспособности вы можете использовать клиент, написанный на
предыдущей неделе.

Давайте еще раз посмотрим на текстовый протокол в действии при использовании утилиты telnet:

$: telnet 127.0.0.1 8888
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
> get test_key
< ok
<
> got test_key
< error
< wrong command
<
> put test_key 12.0 1503319740
< ok
<
> put test_key 13.0 1503319739
< ok
<
> get test_key
< ok
< test_key 13.0 1503319739
< test_key 12.0 1503319740
<
> put another_key 10 1503319739
< ok
<
> get *
< ok
< test_key 13.0 1503319739
< test_key 12.0 1503319740
< another_key 10.0 1503319739
<

Также вы можете воспользоваться вспомогательным скриптом, который использует "'эталонную" реализацию клиента,
открывающуюся после сдачи задания на пятой неделе, для локального тестирования написанного вами сервера:
(support_script.py)
